{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Aurae Aurae is a free and open source Rust project which houses a generic systems runtime daemon built specifically for enterprise distributed systems. Aurae is designed to work well with Kubernetes, and serves as an enterprise focused alternative to systemd. Think of auraed as a pid 1 init machine daemon with a scope similar to systemd and functionality similar to containerd and firecracker . Aurae brings SPIFFE / SPIRE (x509 mTLS) backed identity, authentication (authn) and authorization (authz) as low as the Unix domain socket layer in a distributed system. Aurae exposes its functionality over a gRPC API which is referred to as the Aurae Standard Library . A single Aurae instance has no awareness of higher order scheduling mechanisms such as the Kubernetes control plane. Aurae is designed to take ownership of a single machine, and expose the standard library a generic and meaningful way for higher order consumers. Motivation Read Why fix Kubernetes and Systemd by Kris N\u00f3va . Aurae attempts to simplify and improve the stack in enterprise distributed systems by carving out a small portion of responsibility while offering a few basic guarantees with regard to state, synchronicity, awareness, and security. Aurae brings enterprise identity as low as the socket layer in a system, which unlocks multi tenant workloads that run below tools like Kubernetes. Workloads Aurae supports 3 types of workloads which can be started and scheduled alongside each other on a single machine. Executables (Regular executable processes on a host system. Similar to Systemd Units with ExecStart ). Containers (A secure and opinionated container runtime is baked directly into the Aurae binary). Virtualization (A secure and opinionated hypervisor is baked directly into the Aurae binary). AuraeScript Aurae offers a Turing complete scripting language written in Rust and similar to TypeScript called AuraeScript . let execute = true ; // Toggle execution let aurae = connect (); // Connect to the daemon aurae . info (). json (); // Show identity if execute { // Execute \"cat /etc/resolv.conf\" let runtime = aurae . runtime (); let example = exec ( \"cat /etc/resolv.conf\" ); runtime . start ( example ). json (); } AuraeScript servers as one of many clients to the system and can be used to express workload manifests instead of YAML. AuraeScript can be used to control and gain visibility to the system.","title":"Home"},{"location":"#aurae","text":"Aurae is a free and open source Rust project which houses a generic systems runtime daemon built specifically for enterprise distributed systems. Aurae is designed to work well with Kubernetes, and serves as an enterprise focused alternative to systemd. Think of auraed as a pid 1 init machine daemon with a scope similar to systemd and functionality similar to containerd and firecracker . Aurae brings SPIFFE / SPIRE (x509 mTLS) backed identity, authentication (authn) and authorization (authz) as low as the Unix domain socket layer in a distributed system. Aurae exposes its functionality over a gRPC API which is referred to as the Aurae Standard Library . A single Aurae instance has no awareness of higher order scheduling mechanisms such as the Kubernetes control plane. Aurae is designed to take ownership of a single machine, and expose the standard library a generic and meaningful way for higher order consumers.","title":"Aurae"},{"location":"#motivation","text":"Read Why fix Kubernetes and Systemd by Kris N\u00f3va . Aurae attempts to simplify and improve the stack in enterprise distributed systems by carving out a small portion of responsibility while offering a few basic guarantees with regard to state, synchronicity, awareness, and security. Aurae brings enterprise identity as low as the socket layer in a system, which unlocks multi tenant workloads that run below tools like Kubernetes.","title":"Motivation"},{"location":"#workloads","text":"Aurae supports 3 types of workloads which can be started and scheduled alongside each other on a single machine. Executables (Regular executable processes on a host system. Similar to Systemd Units with ExecStart ). Containers (A secure and opinionated container runtime is baked directly into the Aurae binary). Virtualization (A secure and opinionated hypervisor is baked directly into the Aurae binary).","title":"Workloads"},{"location":"#auraescript","text":"Aurae offers a Turing complete scripting language written in Rust and similar to TypeScript called AuraeScript . let execute = true ; // Toggle execution let aurae = connect (); // Connect to the daemon aurae . info (). json (); // Show identity if execute { // Execute \"cat /etc/resolv.conf\" let runtime = aurae . runtime (); let example = exec ( \"cat /etc/resolv.conf\" ); runtime . start ( example ). json (); } AuraeScript servers as one of many clients to the system and can be used to express workload manifests instead of YAML. AuraeScript can be used to control and gain visibility to the system.","title":"AuraeScript"},{"location":"build/","text":"Building Aurae from Source Checkout the core aurae repository. Note : Aurae currently only has support for Linux on X86 architecture. https://github.com/aurae-runtime/aurae.git Dependencies The Aurae environment depends on the protoc protocol buffer compiler being available within the path. Install protoc using your operating system's package manager (Or from source if you want to :) ) Ubuntu sudo apt install -y protobuf-compiler Arch Linux pacman -S protobuf Prepare the Environment To install Aurae first build the submodules for the project. make submodules # Please do not forget to do this! Next you will need to create authentication certificates and create an ~/.aurae/config file. make pki config # For quick-start only Now you can compile and install the toolchain make You can optionally compile each submodule directly. make auraed # compile and install auraed with cargo make auraescript # compile and install auraescript with cargo","title":"Building Aurae from Source"},{"location":"build/#building-aurae-from-source","text":"Checkout the core aurae repository. Note : Aurae currently only has support for Linux on X86 architecture. https://github.com/aurae-runtime/aurae.git","title":"Building Aurae from Source"},{"location":"build/#dependencies","text":"The Aurae environment depends on the protoc protocol buffer compiler being available within the path. Install protoc using your operating system's package manager (Or from source if you want to :) )","title":"Dependencies"},{"location":"build/#ubuntu","text":"sudo apt install -y protobuf-compiler","title":"Ubuntu"},{"location":"build/#arch-linux","text":"pacman -S protobuf","title":"Arch Linux"},{"location":"build/#prepare-the-environment","text":"To install Aurae first build the submodules for the project. make submodules # Please do not forget to do this! Next you will need to create authentication certificates and create an ~/.aurae/config file. make pki config # For quick-start only Now you can compile and install the toolchain make You can optionally compile each submodule directly. make auraed # compile and install auraed with cargo make auraescript # compile and install auraescript with cargo","title":"Prepare the Environment"},{"location":"certs/","text":"Generating Client Certificate Material For an easy start for managing certificate material you can leverage the convenient make target. make pki config Which uses the scripts in /hack to self sign X509 certificates with mock identities. Creating Clients After the initial PKI has been generated using the above make pki command, clients can easily be created using the following. ./hack/certgen-client <name> Where <name> is a unique string for your client you wish to provide authentication material for.","title":"Generating Client Certificate Material"},{"location":"certs/#generating-client-certificate-material","text":"For an easy start for managing certificate material you can leverage the convenient make target. make pki config Which uses the scripts in /hack to self sign X509 certificates with mock identities.","title":"Generating Client Certificate Material"},{"location":"certs/#creating-clients","text":"After the initial PKI has been generated using the above make pki command, clients can easily be created using the following. ./hack/certgen-client <name> Where <name> is a unique string for your client you wish to provide authentication material for.","title":"Creating Clients"},{"location":"quickstart/","text":"Aurae Quickstart Now that you have built Aurae from source you can begin using Aurae. Running the Daemon Aurae will run on any system, even if systemd or another init daemon is currently active. sudo -E auraed Writing your first AuraeScript First create an executable script anywhere you like. touch ~/hello.aurae chmod +x ~/.hello.aurae Next add the following content. let aurae = connect (); let runtime = aurae . runtime (); aurae . info (). json (); let example = exec ( \"echo 'Hello World!'\" ); runtime . start ( example ). json (); You can now run your first AuraeScript. ~/hello.aurae Your output should be in valid JSON which should look similar to the following: { \"subject_common_name\" : \"nova.unsafe.aurae.io\" , \"issuer_common_name\" : \"unsafe.aurae.io\" , \"sha256_fingerprint\" : \"SHA256:7afa7cbf54dacf8368fd7407039594264c5bb22eaa7f8de5017af53f5ab240b0\" , \"key_algorithm\" : \"RSA\" } { \"meta\" : { \"name\" : \"echo 'Hello World!'\" , \"message\" : \"-\" }, \"proc\" : { \"pid\" : 1428 }, \"status\" : 6 , \"stdout\" : \"'Hello World!'\\n\" , \"stderr\" : \"\" , \"exit_code\" : \"exit status: 0\" } As long as the .json() method is used for output, aurae scripts can be piped to jq for easy usage. ~/hello.aurae | jq -r .stdout","title":"Aurae Quickstart"},{"location":"quickstart/#aurae-quickstart","text":"Now that you have built Aurae from source you can begin using Aurae.","title":"Aurae Quickstart"},{"location":"quickstart/#running-the-daemon","text":"Aurae will run on any system, even if systemd or another init daemon is currently active. sudo -E auraed","title":"Running the Daemon"},{"location":"quickstart/#writing-your-first-auraescript","text":"First create an executable script anywhere you like. touch ~/hello.aurae chmod +x ~/.hello.aurae Next add the following content. let aurae = connect (); let runtime = aurae . runtime (); aurae . info (). json (); let example = exec ( \"echo 'Hello World!'\" ); runtime . start ( example ). json (); You can now run your first AuraeScript. ~/hello.aurae Your output should be in valid JSON which should look similar to the following: { \"subject_common_name\" : \"nova.unsafe.aurae.io\" , \"issuer_common_name\" : \"unsafe.aurae.io\" , \"sha256_fingerprint\" : \"SHA256:7afa7cbf54dacf8368fd7407039594264c5bb22eaa7f8de5017af53f5ab240b0\" , \"key_algorithm\" : \"RSA\" } { \"meta\" : { \"name\" : \"echo 'Hello World!'\" , \"message\" : \"-\" }, \"proc\" : { \"pid\" : 1428 }, \"status\" : 6 , \"stdout\" : \"'Hello World!'\\n\" , \"stderr\" : \"\" , \"exit_code\" : \"exit status: 0\" } As long as the .json() method is used for output, aurae scripts can be piped to jq for easy usage. ~/hello.aurae | jq -r .stdout","title":"Writing your first AuraeScript"},{"location":"auraed/","text":"Aurae Daemon The Aurae Daemon (auraed) is the main daemon that powers Aurae. The Aurae Daemon runs as a gRPC server which listens over a unix domain socket by default. /var/run/aurae/aurae.sock Running Auraed Running as /init is currently under active development. To run auraed as a standard library server you can run the daemon alongside your current init system. sudo -E auraed Additional flags are listed below. USAGE: auraed [OPTIONS] OPTIONS: --ca-crt <CA_CRT> [default: /etc/aurae/pki/ca.crt] -h, --help Print help information -s, --socket <SOCKET> [default: /var/run/aurae/aurae.sock] --server-crt <SERVER_CRT> [default: /etc/aurae/pki/_signed.server.crt] --server-key <SERVER_KEY> [default: /etc/aurae/pki/server.key] -v, --verbose -V, --version Print version information Building from source We suggest using the aurae repository for building all parts of the project. If you intend on building this repository directly you can leverage the Makefile in this repository. make or using Cargo directly cargo clippy cargo install --debug --path .","title":"Aurae Daemon"},{"location":"auraed/#aurae-daemon","text":"The Aurae Daemon (auraed) is the main daemon that powers Aurae. The Aurae Daemon runs as a gRPC server which listens over a unix domain socket by default. /var/run/aurae/aurae.sock","title":"Aurae Daemon"},{"location":"auraed/#running-auraed","text":"Running as /init is currently under active development. To run auraed as a standard library server you can run the daemon alongside your current init system. sudo -E auraed Additional flags are listed below. USAGE: auraed [OPTIONS] OPTIONS: --ca-crt <CA_CRT> [default: /etc/aurae/pki/ca.crt] -h, --help Print help information -s, --socket <SOCKET> [default: /var/run/aurae/aurae.sock] --server-crt <SERVER_CRT> [default: /etc/aurae/pki/_signed.server.crt] --server-key <SERVER_KEY> [default: /etc/aurae/pki/server.key] -v, --verbose -V, --version Print version information","title":"Running Auraed"},{"location":"auraed/#building-from-source","text":"We suggest using the aurae repository for building all parts of the project. If you intend on building this repository directly you can leverage the Makefile in this repository. make or using Cargo directly cargo clippy cargo install --debug --path .","title":"Building from source"},{"location":"auraed/philosophy/","text":"Aurae Daemon Philosophy","title":"Aurae Daemon Philosophy"},{"location":"auraed/philosophy/#aurae-daemon-philosophy","text":"","title":"Aurae Daemon Philosophy"},{"location":"auraescript/","text":"AuraeScript AuraeScript is a turing complete language for platform teams built on Rhai and is similar to TypeScript and Rust. let connect = true ; if connect { let aurae = connect (); aurae . info (). json (); } AuraeScript is a lightweight client that wraps the Aurae Standard Library . AuraeScript is a quick way to access the core Aurae APIs and follows normal UNIX parlance. AuraeScript should feel simple and intuitive for any Go, C, Python, or Rust programmer. #!/usr/bin/env auraescript let client = connect (); // Connect and authenticate with mTLS stored in a ~/.aurae/config client . info (). json (); // Print the connection details as JSON let observe = client . observe () // Initialize the observe subsystem observe . status (). json (); // Print the status of an Aurae system to JSON Build From Source \u26a0\ufe0f Early Active Development \u26a0\ufe0f We suggest building the project from the higher order environment repository. git clone git@github.com:aurae-runtime/environment.git cd environment make submodules pki config all Alternatively it is possible to build aurascript by itself. Check out this repository and use the Makefile. make ...or manually using Cargo. cargo build cargo install --path . Architecture AuraeScript follows a similar client paradigm to Kubernetes kubectl command. However, unlike Kubernetes this is not a command line tool like kubectl . AuraeScript is a fully supported programing language complete with a systems standard library. The Aurae runtime projects supports many clients, and the easiest client to get started building with is AuraeScript. Download the static binary directly to your system, and you can begin writing AuraeScript programs directly against a running Aurae server.","title":"AuraeScript"},{"location":"auraescript/#auraescript","text":"AuraeScript is a turing complete language for platform teams built on Rhai and is similar to TypeScript and Rust. let connect = true ; if connect { let aurae = connect (); aurae . info (). json (); } AuraeScript is a lightweight client that wraps the Aurae Standard Library . AuraeScript is a quick way to access the core Aurae APIs and follows normal UNIX parlance. AuraeScript should feel simple and intuitive for any Go, C, Python, or Rust programmer. #!/usr/bin/env auraescript let client = connect (); // Connect and authenticate with mTLS stored in a ~/.aurae/config client . info (). json (); // Print the connection details as JSON let observe = client . observe () // Initialize the observe subsystem observe . status (). json (); // Print the status of an Aurae system to JSON","title":"AuraeScript"},{"location":"auraescript/#build-from-source","text":"\u26a0\ufe0f Early Active Development \u26a0\ufe0f We suggest building the project from the higher order environment repository. git clone git@github.com:aurae-runtime/environment.git cd environment make submodules pki config all Alternatively it is possible to build aurascript by itself. Check out this repository and use the Makefile. make ...or manually using Cargo. cargo build cargo install --path .","title":"Build From Source"},{"location":"auraescript/#architecture","text":"AuraeScript follows a similar client paradigm to Kubernetes kubectl command. However, unlike Kubernetes this is not a command line tool like kubectl . AuraeScript is a fully supported programing language complete with a systems standard library. The Aurae runtime projects supports many clients, and the easiest client to get started building with is AuraeScript. Download the static binary directly to your system, and you can begin writing AuraeScript programs directly against a running Aurae server.","title":"Architecture"},{"location":"stdlib/","text":"The Aurae Standard Library The Aurae Standard Library (stdlib or \"the library\") is a set of remote functions grouped together into logical groups called subsystems. The library leverages protobuf as the source of truth for the types, names, and function signatures for the library. What is a subsystem? A subsystem is a smaller and scoped subsection of the library. Subsystems are similar to \"packages\" or \"modules\" in programming languages such as Rust . Kubernetes as API groups, and Linux itself has subsystems. Each subsystem is unique. Each subsystem is liable to come with its own guarantees, and expectations. For example the runtime subsystem is adamantly a synchronous subsystem which creates an imperative experience for the client. Contrarywise, the schedule subsystem is adamantly an asynchronous subsystem which instills a declarative model for the client. In protobuf terms a subsystem is a service . What are objects? Aurae is built on the concept of core objects that are useful to distributed systems engineers. For example, Aurae has the concept of an Executable object which can be passed to runtime.StartExecutable and runtime.StopExecutable functions respectively. The core objects are intended to be fundamental and composable, similar to the objects and structures found in modern programming languages. Objects are defined directly in the corresponding protobuf definition and later generated into code for various languages. In protobuf terms an object is a message . What are functions? A function is a discreet piece of functionality designed to execute on the \"backend\", or directly by an Aurae Daemon server. The library is designed to be executed procedurally and quickly. Many function calls per second is a reasonable expectation for any client. In protobuf terms a function is a remote procedure call (RPC) What about metadata? Similar to Kubernetes, Aurae defines some common objects which are embedded in some or all objects in the standard library. Every Aurae object must embed meta.AuraeMeta implying that every object in the library will have a .name and a .message field. message AuraeMeta { string name = 1 ; string message = 2 ; } There are other common objects such as meta.ProcessMeta which is embedded in any object that has a concept of an executing runtime process. API Definition Convention Generally follow this style guide in the proto files. It is short, but the main points are: Files should be named lower_snake_case.proto Files should be ordered in the following manner // AURAE LICENSE HEADER syntax = \"proto3\" ; package lower_snake_case_package_name ; // imports sorted alphabetically import \"path/to/dependency.proto\" ; import \"path/to/other.proto\" ; // file options // everything else Generally follow these rules: Services should be named UpperCamelCase (aka PascalCase) Service methods should be named UpperCamelCase Messages should be named UpperCamelCase Field names, including oneof and extension names, should be snake_case repeated fields should have pluralized names Enums should be named UpperCamelCase Enum variants should be SCREAMING_SNAKE_CASE (Suggested) The zero value enum variants should have the suffix UNSPECIFIED (Suggested) Enums should NOT be nested, and their variants should be prefixed with the enum's name enum FooBar { FOO_BAR_UNSPECIFIED = 0 ; FOO_BAR_FIRST_VALUE = 1 ; FOO_BAR_SECOND_VALUE = 2 ; } A notable exception to the public specification above is the Aurae projects preference for standardizing the objects that are used as the request and response messages. The traditional convention that is meant to reduce the likelihood of future breaking changes and ease the creation of macros for generating code: rpc methods (e.g., StartWidget ) should have dedicated request and response messages named StartWidgetResponse and StartWidgetResponse objects (e.g., Widget ) should be embedded directly into their corresponding StartWidgetRequest , StopWidgetReqyest , etc style methods.","title":"The Aurae Standard Library"},{"location":"stdlib/#the-aurae-standard-library","text":"The Aurae Standard Library (stdlib or \"the library\") is a set of remote functions grouped together into logical groups called subsystems. The library leverages protobuf as the source of truth for the types, names, and function signatures for the library.","title":"The Aurae Standard Library"},{"location":"stdlib/#what-is-a-subsystem","text":"A subsystem is a smaller and scoped subsection of the library. Subsystems are similar to \"packages\" or \"modules\" in programming languages such as Rust . Kubernetes as API groups, and Linux itself has subsystems. Each subsystem is unique. Each subsystem is liable to come with its own guarantees, and expectations. For example the runtime subsystem is adamantly a synchronous subsystem which creates an imperative experience for the client. Contrarywise, the schedule subsystem is adamantly an asynchronous subsystem which instills a declarative model for the client. In protobuf terms a subsystem is a service .","title":"What is a subsystem?"},{"location":"stdlib/#what-are-objects","text":"Aurae is built on the concept of core objects that are useful to distributed systems engineers. For example, Aurae has the concept of an Executable object which can be passed to runtime.StartExecutable and runtime.StopExecutable functions respectively. The core objects are intended to be fundamental and composable, similar to the objects and structures found in modern programming languages. Objects are defined directly in the corresponding protobuf definition and later generated into code for various languages. In protobuf terms an object is a message .","title":"What are objects?"},{"location":"stdlib/#what-are-functions","text":"A function is a discreet piece of functionality designed to execute on the \"backend\", or directly by an Aurae Daemon server. The library is designed to be executed procedurally and quickly. Many function calls per second is a reasonable expectation for any client. In protobuf terms a function is a remote procedure call (RPC)","title":"What are functions?"},{"location":"stdlib/#what-about-metadata","text":"Similar to Kubernetes, Aurae defines some common objects which are embedded in some or all objects in the standard library. Every Aurae object must embed meta.AuraeMeta implying that every object in the library will have a .name and a .message field. message AuraeMeta { string name = 1 ; string message = 2 ; } There are other common objects such as meta.ProcessMeta which is embedded in any object that has a concept of an executing runtime process.","title":"What about metadata?"},{"location":"stdlib/#api-definition-convention","text":"Generally follow this style guide in the proto files. It is short, but the main points are: Files should be named lower_snake_case.proto Files should be ordered in the following manner // AURAE LICENSE HEADER syntax = \"proto3\" ; package lower_snake_case_package_name ; // imports sorted alphabetically import \"path/to/dependency.proto\" ; import \"path/to/other.proto\" ; // file options // everything else Generally follow these rules: Services should be named UpperCamelCase (aka PascalCase) Service methods should be named UpperCamelCase Messages should be named UpperCamelCase Field names, including oneof and extension names, should be snake_case repeated fields should have pluralized names Enums should be named UpperCamelCase Enum variants should be SCREAMING_SNAKE_CASE (Suggested) The zero value enum variants should have the suffix UNSPECIFIED (Suggested) Enums should NOT be nested, and their variants should be prefixed with the enum's name enum FooBar { FOO_BAR_UNSPECIFIED = 0 ; FOO_BAR_FIRST_VALUE = 1 ; FOO_BAR_SECOND_VALUE = 2 ; } A notable exception to the public specification above is the Aurae projects preference for standardizing the objects that are used as the request and response messages. The traditional convention that is meant to reduce the likelihood of future breaking changes and ease the creation of macros for generating code: rpc methods (e.g., StartWidget ) should have dedicated request and response messages named StartWidgetResponse and StartWidgetResponse objects (e.g., Widget ) should be embedded directly into their corresponding StartWidgetRequest , StopWidgetReqyest , etc style methods.","title":"API Definition Convention"},{"location":"stdlib/v0/","text":"V0 Aurae Standard Library The V0 release is an experimental and risky API. This API should never be ran in production as it is subject to change at any time.","title":"V0 Aurae Standard Library"},{"location":"stdlib/v0/#v0-aurae-standard-library","text":"The V0 release is an experimental and risky API. This API should never be ran in production as it is subject to change at any time.","title":"V0 Aurae Standard Library"},{"location":"stdlib/v0/release/","text":"V0 Release Notes The V0 release is an experimental and risky API. This API should never be ran in production as it is subject to change at any time.","title":"V0 Release Notes"},{"location":"stdlib/v0/release/#v0-release-notes","text":"The V0 release is an experimental and risky API. This API should never be ran in production as it is subject to change at any time.","title":"V0 Release Notes"}]}